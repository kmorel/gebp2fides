import adios2
import argparse
import json
import os.path
import re
import sys

cli = argparse.ArgumentParser(
  description='Generates Fides json files for bp files generated by GE simulatoins.',
)

cli.add_argument('input-filename',
                 help='The input bp file.')
cli.add_argument('output-filename', nargs='?',
                 help='The (optional) output filename. If not specified, will use the input filename with the extension replaced.')
cli.add_argument('-f', '--force', action='store_true',
                 help='Force write to the output. Without this argument, this command will fail if the output file already exists.')

args = vars(cli.parse_args())

def print_status(message : str) -> None:
  print(message)

def error_and_quit(message : str, exit_code : int = 1) -> None:
  print(message, file=sys.stderr)
  exit(exit_code)

infile = args['input-filename']
outfile = args['output-filename']
if not outfile:
  index = infile.rfind('.bp')
  outfile = infile[:index] + '.fides.json'
if os.path.exists(outfile) and not args['force']:
  error_and_quit(f'Outfile file {outfile} already exists. To overwrite, use the `--force` option.')

# Capture variables in input(s).
sources = {}
with adios2.FileReader(infile) as input:
  variables = set()
  for name, info in input.available_variables().items():
    variables.add(name)
  sources["source"] = variables

grid = { "data_sources" : [] }

for source in sources.keys():
  grid["data_sources"].append({
    "name": source,
    "filename_mode": "relative",
    # FIXME: This should be relative to the output file, not where we ran this.
    # "filename": infile,
    "filename": os.path.relpath(os.path.realpath(infile),
                                os.path.dirname(os.path.realpath(outfile)))
  })


coord_prefix = "/hpMusic_base/hpMusic_Zone/GridCoordinates"
coord_array = { "array_type" : "composite" }
for axis in [ 'X', 'Y', 'Z' ]:
  array_name = coord_prefix + "/Coordinate" + axis
  if not array_name in variables:
    error_and_quit(f'File {infile} missing coordinate system array {array_name}')
  print_status(f'Found {axis} coordinates ({array_name})')
  coord_array[axis.lower() + "_array"] = {
    "array_type" : "basic",
    "data_source": "source",
    "variable" : array_name,
  }
grid["coordinate_system"] = { "array": coord_array }

conn_array = "/hpMusic_base/hpMusic_Zone/Elem/ElementConnectivity"
if conn_array in variables:
  print_status(f'Found connectivty ({conn_array})')
  grid["cell_set"] = {
    "cell_set_type" : "single_type",
    "cell_type" : "hexahedron",
    "data_source": "source",
    "variable" : conn_array
  }
else:
  error_and_quit(f'File {infile} missing element connectivity array.')

fields = []
step_info = None
field_matcher = re.compile(r'/hpMusic_base/hpMusic_Zone/FlowSolution/(.*)')
for source in sources.keys():
  for variable in sorted(sources[source]):
    match = field_matcher.fullmatch(variable)
    if match:
      print_status(f'Found field {match.group(1)} ({variable})')
      fields.append({
        "name": match.group(1),
        "association": "points",
        "array": {
          "array_type" : "basic",
          "data_source" : source,
          "variable" : variable
        }
      })
    elif "time" in variable:
      print_status(f'Found time ({variable})')
      step_info = {
        "data_source" : source,
        "variable" : variable
      }
grid["fields"] = fields
if step_info:
  grid["step_information"] = step_info

fides_data = { "HPMUSIC": grid }

with open(outfile, 'w') as output:
  json_data = json.dump(fides_data, output, indent=2)
  output.write('\n')
